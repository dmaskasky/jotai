---
title: Mixins
nav: 3.04
keywords: mixins,setSelf,withSetSelf,signal,withSignal,abort,abortcontroller,mount,withMount,onMount
---

Mixins are utilities that enhance or modify the behavior of atom constructors, providing additional functionality while maintaining the same API.

## How mixins work

The mixin utility wraps the atom constructor to provide additional functionality.

```ts
const atomWithSetSelf = withSetSelf(atom)
const myAtom = atomWithSetSelf(
  (get, { setSelf }) => {...},
  (get, set) => {...},
)
```

## withSignal

#### `options.signal`

The `withSignal` utility provides access to the `signal` functionality through a mixin pattern. It uses [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) so that you can abort async functions.
Abort is triggered before new calculation (invoking `read` function) is started.

### Usage

```ts
import { atom } from 'jotai'
import { withSignal } from 'jotai/utils'

const atomWithSignal = withSignal(atom)

const readOnlyDerivedAtom = atomWithSignal(async (get, { signal }) => {
  // use signal to abort your function
})

const writableDerivedAtom = atomWithSignal(
  async (get, { signal }) => {
    // use signal to abort your function
  },
  (get, set, arg) => {
    // ...
  },
)
```

The `signal` value is [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal).
You can check `signal.aborted` boolean value, or use `abort` event with `addEventListener`.

For `fetch` use case, we can simply pass `signal`.

### Example with fetch

<Stackblitz id="vitejs-vite-ccqxix" file="src%2FApp.tsx" />

```tsx
import { Suspense } from 'react'
import { atom, useAtom } from 'jotai'
import { withSignal } from 'jotai/utils'

const atomWithSignal = withSignal(atom)

const userIdAtom = atom(1)
const userAtom = atomWithSignal(async (get, { signal }) => {
  const userId = get(userIdAtom)
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/users/${userId}?_delay=2000`,
    { signal },
  )
  return response.json()
})

const Controls = () => {
  const [userId, setUserId] = useAtom(userIdAtom)
  return (
    <div>
      User Id: {userId}
      <button onClick={() => setUserId((c) => c - 1)}>Prev</button>
      <button onClick={() => setUserId((c) => c + 1)}>Next</button>
    </div>
  )
}

const UserName = () => {
  const [user] = useAtom(userAtom)
  return <div>User name: {user.name}</div>
}

const App = () => (
  <>
    <Controls />
    <Suspense fallback="Loading...">
      <UserName />
    </Suspense>
  </>
)
```

### Signature

```ts
function withSignal<Value>(
  atomConstructor: typeof atom,
): (
  read: (get: Getter, options: { signal: AbortSignal }) => Value,
  write?: Write<Args, Result>,
) => Atom<Value>
```

## withSetSelf

#### `options.setSelf`

The `withSetSelf` utility provides access to the `setSelf` functionality through a mixin pattern. It's a special function to invoke the write function of the self atom.

⚠️ It's provided primarily for internal usage and third-party library authors. Read the source code carefully to understand the behavior. Check release notes for any breaking/non-breaking changes.

### Usage

```jsx
import { atom } from 'jotai'
import { withSetSelf } from 'jotai/utils'

const atomWithSetSelf = withSetSelf(atom)

const autoRefreshAtom = atomWithSetSelf(
  (get, { setSelf }) => {
    const promise = get(someAsyncAtom)

    promise.then((value) => {
      promiseCache.set(promise, value)
      setSelf()
    })
  },
  (_get, set) => {
    // handle write
  },
)
```

### Signature

```ts
// read-only derived atom
function withSetSelf<Value>(
  atomConstructor: typeof atom,
): (read: (get: Getter, options: { setSelf: never }) => Value) => Atom<Value>

// writable derived atom
function withSetSelf<Value, Args extends unknown[], Result>(
  atomConstructor: typeof atom,
): (
  read: (get: Getter, options: { setSelf: (...args: Args) => Result }) => Value,
  write: Write<Args, Result>,
) => WritableAtom<Value, Args, Result>
```

### Important Notes

- `setSelf` can only be used with writable atoms (atoms that have a write function)
- `setSelf` must be called asynchronously - calling it during synchronous read execution will show a warning in development mode

## withMount

The `withMount` utility provides a way to add `onMount` functionality to existing atoms through a mixin pattern. This is the recommended approach for adding mount/unmount lifecycle behavior to writable atoms.
`onMount` is a function which takes a function `setAtom` and returns `onUnmount` function optionally.

### Usage

```ts
const anAtom = atom(1)
anAtom.onMount = (setAtom) => {
  console.log('atom is mounted in provider')
  setAtom(c => c + 1) // increment count on mount
  return () => { ... } // return optional onUnmount function
}

const Component = () => {
  // `onMount` will be called when the component is mounted in the following cases:
  useAtom(anAtom)
  useAtomValue(anAtom)

  // however, in the following cases,
  //  `onMount` will not be called because the atom is not subscribed:
  useSetAtom(anAtom)
  useAtomCallback(
    useCallback((get) => get(anAtom), []),
  )
  // ...
}
```

### Signature

```ts
// For writable atoms only
function withMount<Value, Args extends unknown[], Result>(
  baseAtom: WritableAtom<Value, Args, Result>,
  onMount: (setAtom: (...args: Args) => Result) => (() => void) | void,
): WritableAtom<Value, Args, Result>
```
